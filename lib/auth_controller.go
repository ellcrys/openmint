// This controller contains address related actions
package lib

import (
	"encoding/json"
	"io/ioutil"
	"net/url"
	"time"

	"github.com/asaskevich/govalidator"
	"github.com/dghubble/oauth1"
	"github.com/dghubble/oauth1/twitter"
	jwt "github.com/dgrijalva/jwt-go"
	"github.com/ellcrys/openmint/config"
	"github.com/ellcrys/openmint/extend"
	"github.com/ellcrys/openmint/models"
	"github.com/ellcrys/util"
	"github.com/franela/goreq"
	"github.com/labstack/echo/engine/standard"
	"gopkg.in/mgo.v2"
	"gopkg.in/mgo.v2/bson"
)

const TWITTER_CB_URL = "http://192.168.1.3:4001/v1/auth/twitter/cb"

type AuthController struct {
	mongoSession *mgo.Session
	twitterOAuth *oauth1.Config
}

func NewAuthController(mongoSession *mgo.Session) *AuthController {
	return &AuthController{
		mongoSession: mongoSession,
		twitterOAuth: &oauth1.Config{
			ConsumerKey:    config.C.GetString("twitter_con_key"),
			ConsumerSecret: config.C.GetString("twitter_con_secret"),
			CallbackURL:    TWITTER_CB_URL,
			Endpoint:       twitter.AuthorizeEndpoint,
		},
	}
}

// @API: POST /v1/auth/me
//
// @Description:
// 	Get the user associated with a jwt session token specified to
// 	in the Authorization header
//
// @Header.Authorization:
// 	Provide the user's jwt session token. e.g "Bearer Abxhsgggaa"
//
// @Response 200: Returns models.UserModel instance
func (self *AuthController) GetUser(c *extend.Context) error {

	// get the authenticated user id
	authUserId := c.Get("auth_user")

	user, err := models.User.FindById(self.mongoSession, authUserId)
	if err != nil {
		return config.NewHTTPError(c.Lang(), 500, "e500")
	}

	user.AccessToken = ""
	user.AccessSecret = ""

	return c.JSON(200, user)
}

// Given a facebook access token, it uses the facebook
// token debug endpoint to determine whether the token
// was generated for a user and by our application.
func (self *AuthController) CheckFBToken(userId, token string) (bool, error) {

	qs := url.Values{}
	qs.Set("input_token", token)
	qs.Set("access_token", config.C.GetString("fb_app_token"))

	res, err := goreq.Request{
		Uri:         "https://graph.facebook.com/debug_token",
		QueryString: qs,
		Timeout:     15 * time.Second,
	}.Do()

	if err != nil {
		return false, err
	}

	var fbResp map[string]interface{}
	res.Body.FromJsonTo(&fbResp)
	fbResp = fbResp["data"].(map[string]interface{})

	util.Println("Token Debug:", fbResp)

	// token is invalid
	if fbResp["is_valid"] == nil || fbResp["is_valid"].(bool) == false {
		return false, nil
	}

	// token not generated by this app
	if fbResp["app_id"] == nil || fbResp["app_id"].(string) != config.C.GetString("fb_app_id") {
		return false, nil
	}

	if fbResp["user_id"] == nil || fbResp["user_id"].(string) != userId {
		return false, nil
	}

	return true, nil
}

// @API: POST /v1/auth/social
//
// @Description:
//  Social login handler. Creates a new user when
//  no matching user exists for the social login provider
//  used and returns a the new user and a session access token.
//  If user exists, the user is returned along with a session access token.
//
// @Content-Type: 	application/json
//
// @Body Params:
// 	full_name 	{string}: The full name of the user
// 	email 		{string}: The email address of the user
// 	photo_url   {string}: Photo URL
// 	provider 	{string}: The social login provider
//	provider_id {string}: The id of the user on the provider's platform
// 	user_token 	{string}: The user access token generated by the provider
//
// @Response 200:
// 	id 			{string}: The id of the user
// 	full_name 	{string}: The full name of the user
// 	email 		{string}: The email address of the user
// 	photo_url	{string}: Photo url of user
// 	provider 	{string}: The social login provider
//	provider_id {string}: The id of the user on the provider's platform
// 	user_token 	{string}: The user access token generated by the provider
// 	token 		{string}: The session token for this user. Used to authenticate request on behalf of user.
// 	created_at 	{Date}:   The date user was created
//
func (self *AuthController) SocialAuth(c *extend.Context) error {

	var body models.UserModel
	if c.BindJSON(&body) != nil {
		return config.NewHTTPError(c.Lang(), 400, "e001")
	}

	if _, err := govalidator.ValidateStruct(body); err != nil {
		return config.ValidationError(c, err)
	}

	// verify user token for facebook provider
	if body.Provider == "facebook" {
		if valid, err := self.CheckFBToken(body.ProviderUserId, body.AccessToken); err != nil || !valid {
			if err != nil {
				util.Println("Failed to check fb token. ", err.Error())
				return config.NewHTTPError(c.Lang(), 500, "e500")
			}
			return config.NewHTTPError(c.Lang(), 401, "e010")
		}
	}

	// find existing user with matching email.
	// If found and the provider name and id matches, return new access token.
	user, err := models.User.FindByField(self.mongoSession, "email", body.Email)
	if err == nil && user.Provider == body.Provider && user.ProviderUserId == body.ProviderUserId {

		// update user token
		if err = models.User.UpdateField(self.mongoSession, user.Id.Hex(), "access_token", body.AccessToken); err != nil {
			return config.NewHTTPError(c.Lang(), 500, "e500")
		}

		// create access token
		token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
			"id":  user.Id.Hex(),
			"iat": time.Now().Unix(),
		})

		user.AccessToken = ""
		user.TokenString, err = token.SignedString([]byte(config.C.GetString("hmac_key")))
		if err != nil {
			return config.NewHTTPError(c.Lang(), 500, "e500")
		}

		return c.JSON(200, user)
	}

	if err != nil && err != mgo.ErrNotFound {
		return config.NewHTTPError(c.Lang(), 500, "e500")
	}

	body.Id = models.NewId()
	if err = models.User.Create(self.mongoSession, &body); err != nil {
		return config.NewHTTPError(c.Lang(), 500, "e500")
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"id":  body.Id.Hex(),
		"iat": time.Now().Unix(),
	})

	body.AccessToken = ""
	body.TokenString, err = token.SignedString([]byte(config.C.GetString("hmac_key")))
	if err != nil {
		return config.NewHTTPError(c.Lang(), 500, "e500")
	}

	return c.JSON(201, body)
}

// @API: GET /v1/auth/twitter/request_token
// @Description: Get twitter request token
func (self *AuthController) GetTwitterRequestToken(c *extend.Context) error {

	requestToken, requestSecret, err := self.twitterOAuth.RequestToken()
	if err != nil {
		return config.NewHTTPError(c.Lang(), 500, "e500")
	}

	newTwitterAuth := &models.TwitterAuthModel{
		Id:               models.NewId(),
		OauthToken:       requestToken,
		OauthTokenSecret: requestSecret,
	}

	if err := models.TwitterAuth.Create(self.mongoSession, newTwitterAuth); err != nil {
		return config.NewHTTPError(c.Lang(), 500, "e500")
	}

	authUrl, err := self.twitterOAuth.AuthorizationURL(requestToken)
	if err != nil {
		return config.NewHTTPError(c.Lang(), 500, "e500")
	}

	return c.JSON(200, extend.H{
		"authUrl": authUrl.String(),
	})
}

// @Description: Render a blank page.
func (self *AuthController) Blank(c *extend.Context) error {
	return c.String(200, "")
}

// @API: GET /auth/twitter/cb
// @Description: Handle twitter oauth callback
func (self *AuthController) TwitterCallback(c *extend.Context) error {

	req := c.Request().(*standard.Request).Request
	requestToken, verifier, err := oauth1.ParseAuthorizationCallback(req)
	if err != nil {
		return c.Echo().Redirect(301, "/v1/auth/twitter/done?error=server_error")
	}

	twitterAuth, err := models.TwitterAuth.FindByField(self.mongoSession, "oauth_token", requestToken)
	if err != nil {
		return c.Echo().Redirect(301, "/v1/auth/twitter/done?error=server_error")
	}

	// defer delete of twitter auth record
	defer func() {
		models.TwitterAuth.Delete(self.mongoSession, twitterAuth.Id.Hex())
	}()

	accessToken, accessSecret, err := self.twitterOAuth.AccessToken(requestToken, twitterAuth.OauthTokenSecret, verifier)
	if err != nil {
		util.Println("Failed to exchange token for access token")
		return c.Echo().Redirect(301, "/v1/auth/twitter/done?error=server_error")
	}

	// get basic user information
	token := oauth1.NewToken(accessToken, accessSecret)
	httpClient := self.twitterOAuth.Client(oauth1.NoContext, token)
	path := "https://api.twitter.com/1.1/account/verify_credentials.json"
	resp, err := httpClient.Get(path)
	defer resp.Body.Close()
	if err != nil {
		util.Println("Failed to verify access token")
		return c.Echo().Redirect(301, "/v1/auth/twitter/done?error=server_error")
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		util.Println("Failed to read access token info response body")
		return c.Echo().Redirect(301, "/v1/auth/twitter/done?error=server_error")
	}

	decodedBody, err := util.JSONToMap(string(body))
	if err != nil {
		util.Println("Failed to decode response body from twitter")
		return c.Echo().Redirect(301, "/v1/auth/twitter/done?error=server_error")
	}

	// find existing user
	providerUserId := decodedBody["id"].(json.Number).String()
	user, err := models.User.FindByField(self.mongoSession, "provider_id", providerUserId)
	if err != nil && err != mgo.ErrNotFound {
		util.Println("Failed to complete `find` for existing twitter user")
		return c.Echo().Redirect(301, "/v1/auth/twitter/done?error=server_error")
	}

	// user exists
	if err == nil {

		// update access token and secret token
		newUpdate := bson.M{"access_token": accessToken, "access_secret": accessSecret}
		if err = models.User.Update(self.mongoSession, user.Id.Hex(), bson.M{"$set": newUpdate}); err != nil {
			return c.Echo().Redirect(301, "/v1/auth/twitter/done?error=server_error")
		}

		// create session token
		token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
			"id":  user.Id.Hex(),
			"iat": time.Now().Unix(),
		})

		user.TokenString, err = token.SignedString([]byte(config.C.GetString("hmac_key")))
		if err != nil {
			return c.Echo().Redirect(301, "/v1/auth/twitter/done?error=server_error")
		}

		return c.Echo().Redirect(301, "/v1/auth/twitter/done?session_token="+user.TokenString)
	}

	newUser := &models.UserModel{
		Id:             models.NewId(),
		Fullname:       decodedBody["name"].(string),
		PhotoURL:       decodedBody["profile_image_url_https"].(string),
		Provider:       "twitter",
		ProviderUserId: decodedBody["id"].(json.Number).String(),
		AccessToken:    accessToken,
		AccessSecret:   accessSecret,
	}

	// create session token
	sessionToken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"id":  newUser.Id.Hex(),
		"iat": time.Now().Unix(),
	})

	newUser.TokenString, _ = sessionToken.SignedString([]byte(config.C.GetString("hmac_key")))
	if err = models.User.Create(self.mongoSession, newUser); err != nil {
		util.Println("Failed to create new twitter user")
		return c.Echo().Redirect(301, "/v1/auth/twitter/done?error=server_error")
	}

	return c.Echo().Redirect(301, "/v1/auth/twitter/done?session_token="+newUser.TokenString)
}
